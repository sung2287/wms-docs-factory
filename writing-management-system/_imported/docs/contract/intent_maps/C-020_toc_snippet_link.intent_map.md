# C-020_toc_snippet_link.intent_map.md

## 1. 설계 철학 (Philosophy)
"구조(Structure)와 내용(Content)의 완전한 분리"

본 시스템에서 TOC(Tree)는 문서의 뼈대를 의미하며, Snippet은 지식의 파편(Content Block)을 의미한다. 
TOC 노드는 내용을 담는 그릇이 아니라 내용을 가리키는 포인터 역할을 수행함으로써, 동일한 지식 조각을 문서의 여러 곳에서 재사용하거나 순서를 자유롭게 변경할 수 있는 유연성을 확보한다.

## 2. 핵심 의사결정 및 근거 (Key Decisions & Rationale)

### 2.1 단방향 참조 (Tree → Snippet)
- **이유:** 시스템 복잡도를 낮추기 위함이다. 역참조(Snippet → Node)를 허용할 경우 Snippet 이동이나 삭제 시 모든 관련 노드를 탐색해야 하는 부하가 발생하며, 순환 참조의 위험이 있다.
- **결과:** Tree는 Snippet의 존재 여부와 상관없이 구조를 유지하며, Snippet은 자신을 누가 쓰는지 신경 쓰지 않는 독립적인 데이터 조각이 된다.

### 2.2 다중 참조(재사용) 허용
- **이유:** 동일한 문구(예: 주의사항, 공통 정의)를 문서 내 여러 챕터에서 반복해서 보여줘야 할 경우, 데이터를 복사하지 않고 참조만으로 해결하기 위함이다.
- **결과:** Snippet 하나를 수정하면 이를 참조하는 모든 TOC 노드에서 변경사항이 즉시 반영된다.

### 2.3 Dangling 참조 허용 및 UI Degrade
- **이유:** Snippet 삭제 시 모든 참조 노드를 즉시 수정하는 것은 트랜잭션 비용이 높고 실패 가능성이 있다. 
- **결과:** 데이터 정합성을 강제하기보다, UI 수준에서 "삭제된 내용"이라는 상태를 사용자에게 명확히 전달함으로써(Graceful Degradation) 사용자 경험을 보호한다.

### 2.4 탐색기형(Explorer) UI 선택
- **이유:** 사용자가 전체 문서를 한꺼번에 보기보다는, 목차를 탐색하며 특정 섹션의 내용을 확인하고 수정하는 작업 흐름에 최적화하기 위함이다. 이는 VSCode와 같은 IDE의 작업 방식과 유사하여 사용자에게 익숙한 경험을 제공한다.

### 2.5 Node의 독립적 존재 허용
- **내용:** TreeNode는 내용(Snippet) 없이도 존재할 수 있다.
- **이유:** 구조 설계(목차 작성)와 내용 작성은 분리된 단계이다. 이는 사용자가 먼저 문서의 뼈대를 설계하고, 이후 점진적으로 내용을 채워나갈 수 있도록 하기 위함이다.

## 3. 구조와 내용의 분리 (Separation)

- **Tree (TOC):** 순서(Order), 계층(Hierarchy), 넘버링(Numbering)을 담당한다.
- **Snippet (Pool):** 텍스트(Value), 타입(Kind), 메타데이터를 담당한다.
- **Connection (Link):** `linkedSnippetId`를 통한 약한 연결(Loose Coupling)을 유지한다.
