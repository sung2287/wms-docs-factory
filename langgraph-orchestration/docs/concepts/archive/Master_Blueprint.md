# **🚀 \[Master Blueprint\] AI 장기기억 저술 SaaS & 메타 팩토리 아키텍처**

## **1\. 제품의 본질 (Core Identity)**

**"99%의 대중에게 창작의 환상을, 1%의 설계자에게 시스템 통제권을"**

* **대중의 오해:** 딸깍 한 번에 완벽한 장편 소설을 써주는 단일 마법 AI가 존재할 것이다.  
* **우리의 진실:** 완벽한 결과물은 AI의 지능이 아니라, 백엔드에 촘촘하게 설계된 \*\*'결정론적 메타 파이프라인(LangGraph)'\*\*에서 나온다.  
* **가치 제안:** 사용자는 그저 AI와 '대화'만 하지만, 백엔드 시스템이 사용자의 의도를 정해진 스키마에 몰래 채워 넣으며 일관성 있는 거대한 세계관을 자동으로 직조한다.

## **2\. 투트랙 아키텍처 (Builder vs Runtime 분리)**

모든 업무 자동화를 뚝딱 찍어내기 위해, 개발 환경과 서비스 환경을 완벽히 분리한다. (단일 JSON이라는 마케팅 용어 이면의 진짜 엔지니어링 구조)

### **(A) 통제실: 개인용 설계 앱 (Builder / Control Plane)**

* **목적:** 아키텍트가 UI만으로 업무 파이프라인을 깎고 테스트하는 만능 R\&D 랩실.  
* **출력물:** 단순한 JSON 파일 하나가 아니라, 프롬프트(.md), 정책(.yaml), 평가 기준(.json)이 하나로 묶인 \*\*'배포 가능한 파이프라인 번들(Workflow Bundle)과 Manifest'\*\*를 생성.  
* **테스트 (HITL):** 각 노드마다 '수동 개입(Interrupt)' 모드를 켜서 퀄리티를 핀셋 검증.

### **(B) 승격 파이프라인 (Promotion Pipeline)**

* 설계 앱에서 검증을 마친 번들을 제품 엔진으로 밀어 넣는 **'Deploy(승격)'** 과정.  
* **\[LOCK-1\] SSOT 분리 선언:** 승격(Promote)되는 대상은 오직 'Workflow Bundle(컨텍스트 엔지니어링 스펙)'뿐이며, 유저의 실제 데이터(원문/기억/세계관)는 절대 승격 대상에 섞이지 않도록 완벽히 커플링을 차단한다.  
* **\[LOCK-3\] 제한적 핫스왑 (Hot-swap Scope):** 1인 운영의 MVP로 파일 복사/심볼릭 링크 교체를 사용하되, 번들 구성요소별로 허용 범위가 다르다.  
  * *Live Reload 가능:* prompts, rubrics, 일부 routing rule (무중단 패치)  
  * *Restart Required:* step contract, schema 변경, graph shape 변경 (재시작 요구)

### **(C) 실행기: B2C 제품 엔진 (Runtime / Data Plane)**

* **목적:** 대중(99%)이 사용하는 단순하고 직관적인 대화형 UI (엔진은 도메인 입력→실행→결과/상태 반환 역할만 수행).  
* **오토파일럿 (Prod Mode) \[LOCK-2\]:** 런타임 환경에서는 인간의 개입(HITL)이 단순히 '꺼지는' 것이 아니라, **'승인/검수의 주체'를 판사 AI(Judge Policy)로 대체**하는 것이다.  
* **🔥 \[LOCK-4\] 코어 강제 규칙 (Core-enforced Fallback):** Judge Policy의 구체적인 '판단 기준'은 번들에 포함되어 배포되지만, 판단 실패, 보류, 불확실성 발생 시의 처리 구조(재시도/에스컬레이션/중단)는 반드시 Runtime Core에 하드코딩된 Fallback Contract를 따르도록 강제한다. (설계자의 위험한 자동화 정책 배포로 인한 시스템 붕괴 원천 차단)
* **🔥 \[LOCK-5\] 가디언 루프 (Guardian/Validator Loop):** Runtime Core는 실행 전/후에 Policy Memory를 대조하는 Validator Hook을 강제로 실행한다. 이 검사는 **ALLOW(통과), WARN(UI 알림 후 진행), BLOCK(중단)**의 3단계 신호를 반환하며, 시스템 무결성을 실시간으로 수호한다.

## **3\. 백엔드 에이전틱 워크플로우 (Planner-Worker 구조)**

단일 AI의 '기억 상실'과 '설정 붕괴'를 막기 위한 인지 아키텍처.

* **디렉터(판사) 노드:** 가장 똑똑한 AI(고비용). 전체 숲을 보며 설계도를 검토하고 워커에게 "이 부분 충돌 없는지 조사해 와" 지시.  
* **워커(수사관) 노드:** 가성비 AI. 방대한 레포지토리를 뒤져 증거를 수집하고 요약 리포트만 바침.  
* **Letta 장기 기억 (앵커):** 어둠 속(원문 DB)을 비추는 '손전등'. 현재 대화의 맥락을 이해하고 원문 DB의 세계관과 맵핑.

### **3.1 인지 뼈대: 3층 메모리 시스템 (Memory Hierarchy)**

*   **① Semantic Memory (맥락):** 유사한 과거 대화 및 자산 검색 (RAG/Letta Anchor).
*   **② Structural Memory (관계):** 개체 간 위계와 의존성 파악 (Knowledge Graph). "A를 고치면 B가 깨지는가?"를 판단하는 설계의 지도.
*   **③ Policy Memory (규칙):** 절대 변해서는 안 되는 Invariant(불변성). 번들로 주입된 정책(Bundle/Policy)이 여기서 강제됨.

## **4\. 기억과 과금의 헌법 (Memory & BM Constitution)**

**"우리는 기록(데이터)을 인질로 잡지 않는다. 기억의 선명도(컨텍스트)를 팔 뿐이다."**

* **원문 DB (불변의 암흑 창고):** 사용자의 모든 설정, 대화 원문 평생 보존. (S3 콜드 스토리지)  
* **과금 로직 (데이터 티어링):** \* **유료 티어:** 손전등이 최대 출력으로 켜져 비싼 벡터 DB(Hot Storage)로 이관.  
  * **무료 티어 (동면):** 데이터는 S3에 동면(Archive)되나, 최근 대화 맥락만 유지('망각 현상'으로 포장).

### **💡 킬러 UX: "아하 모멘트 (Aha Moment)"**

유료 결제 시 복구 연출:

1. **맥락 연결:** "현재 대화 맥락을 원문 DB의 세계관과 맵핑 중입니다..." (시냅스 연출)  
2. **볼륨 증명:** "인물 14명, 플롯 5개 앵커 연결" (매몰 비용 증명)  
3. **AI의 선빵:** AI가 잊고 있던 과거의 핵심 떡밥을 먼저 짚어주며 대화 시작.

## **5\. 글로벌 확장성 (Global Scalability)**

* **뼈대 독립성:** 랭그래프 엔진 코드 수정 없이 Output Language 변수만 교체.  
* **UI i18n:** 프론트엔드 다국어 매핑(JSON)으로 즉각적인 언어 전환.  
* **크로스 링구얼 기억:** 한국어 원문 DB를 읽고 영미권 톤앤매너로 소설 맵핑.  
* **문화적 튜닝 라우팅:** 설계 앱에서 국가별 감성에 맞춘 전용 '번들'을 제작하여 각국 엔진에 배포.

## **6\. 위기관리 매뉴얼 (4대 윤리 공격 방어망)**

**이 서비스가 공격받는 이유는 비윤리적이어서가 아니라, 인간의 창작·기억·사유를 너무 정확하게 건드리기 때문이다.**

* ① **관계 과금 프레임:** "우리는 관계를 팔지 않는다. 관리 비용을 받는다."  
* ② **창작 착취 프레임:** "우리는 글을 대신 쓰지 않는다. 결정을 내리기 쉽게 만든다." (의사결정 증폭기)  
* ③ **인지 외주화 프레임:** "이 시스템은 사고를 대체하지 않는다. 사고의 흔적을 관리한다."  
* ④ **디스토피아 프레임:** "시스템은 가능성을 제안할 뿐, 결정을 몰래 고정하지 않는다."

## **7\. 핵심 원칙: 연료 게이지 원칙 (The Fuel Gauge Principle)**

**비밀(엔진/설계)은 숨겨도 된다. 하지만 상태(연료 게이지)는 절대 숨겨선 안 된다.**

* 랭그래프 구조나 결정 슬롯은 완벽히 은닉.  
* 단, 시스템의 텔레메트리(Telemetry) 이벤트를 활용해 AI가 \*\*어디까지 기억하고 있는지, 왜 이 결정을 했는지(Explainability)\*\*를 사용자 UI에 투명하게 노출하여 통제감을 부여함.

## **8\. \[Engineering\] 파이프라인 번들 매니페스트 (Manifest Spec)**

Builder에서 Runtime으로 승격(Promote)되는 manifest.json의 핵심 구조. 단순 JSON이 아닌, 버저닝된 아티팩트의 뼈대.

* **A. 정체성 및 호환성:** bundle\_id, bundle\_version, bundle\_hash \+ schema\_version, min\_runtime\_version  
* **B. 구성요소 참조:** prompts\[\] (.md) / policies\[\] (.yaml) / rubrics\[\] (.json)  
* **C. 런타임 적용 범위:** routing (모드 규칙), steps (입출력 Contract)  
* **D. R\&D ↔ Prod 스위치:** \* rd: HITL require\_human: true 허용.  
  * prod: 판사 AI 승인 주체화 (auto\_approver).  
* **E. 관측 및 상태 (Telemetry):** 연료 게이지 UX를 위한 상태 이벤트 정의.  
* **F. 롤백 및 안전장치:** previous\_bundle\_ref 또는 rollback\_to.
* **G. 확장성 포트 (Strategy Injection):** 번들은 단순히 프롬프트만 담는 게 아니라, 해당 도메인에 최적화된 **'리트리벌 전략(Retrieval Strategy)'**과 **'검증 로직(Validator)'**을 런타임에 주입한다. 이를 통해 Core 수정 없이도 도메인별로 각기 다른 3층 메모리 운용 방식이 결정된다.

## **9\. Future Extension (장기 확장 로드맵)**

1인 MVP 운영 이후, 장기적인 SaaS 스케일업을 위해 다음의 권한/배포 모델을 Runtime Core에 추가 확장한다.

* **Stable / Canary 채널 분리 배포:** 새 번들 배포 시 전체 유저가 아닌 일부 트래픽에만 우선 적용하여 퀄리티 검증.  
* **A/B 테스트 라우팅:** 복수의 번들을 동시 운영하여 수익률(CVR)이나 잔존율이 더 높은 프롬프트/정책을 데이터 기반으로 승격.  
* **멀티 테넌트 번들 할당:** 특정 B2B 고객사 전용의 프라이빗 번들(Custom Pipeline) 격리 운영.

## 프로젝트 확장 로드맵: "전문가의 도구에서 모두의 비서로"
[Phase 1] 랭그래프 코어 정교화 및 전문가용 플랫폼 (1% 대상)
이 단계의 목표는 **'통제권'**과 **'노하우 수집'**입니다.

중심 엔진 (LangGraph): 도메인 중립적인 Core Runtime을 완성합니다.

세부 프로젝트 #1 (코딩): 아키텍트와 시니어 개발자를 위한 **'구조적 정합성 엔진'**을 제공합니다.

사용자의 로컬 레포지토리와 연결되어, 복잡한 의존성을 기억하고 검증하는 실무 중심의 기능을 오픈합니다.

세부 프로젝트 #2 (저술): 전문 작가를 위한 **'세계관 정합성 엔진'**을 제공합니다.

3층 메모리(Structural/Policy)를 활용해 수만 장의 설정과 복선을 AI가 관리하도록 돕습니다.

전략적 핵심: 전문가들이 시스템을 사용하며 입력하는 **정책(Policy)**과 의사결정(Decision) 패턴을 데이터화하여 **'워크플로우 번들'**의 퀄리티를 극한으로 끌어올립니다.

[Phase 2] 대중용 '딸깍' 서비스 및 개인 비서 확장 (99% 대상)
1단계에서 검증된 고퀄리티 워크플로우를 대중에게 **'비서'**라는 인터페이스로 공급합니다.

비서 기반 통합 UI: 사용자의 일상 대화를 기억하는 **'Personal AI Secretary'**로 시작합니다.

도메인 팩(Domain Pack) 추가:

"코딩 도메인 추가": 전문가들의 노하우가 응축된 '코딩 번들'을 이식하여, 일반인도 자연어로 "내 PC에서 이런 앱 만들어줘"라고 하면 로컬 에이전트가 실무를 대행합니다.

"저술 도메인 추가": 검증된 '저술 번들'을 통해 누구나 일관성 있는 웹소설이나 보고서를 '딸깍'으로 생성합니다.

전략적 핵심: 대중은 복잡한 설정을 보지 않습니다. 백엔드에서 **가디언 루프(Guardian Loop)**가 전문가의 기준대로 결과물을 자동 검토하여 '딸깍'만으로도 전문가 수준의 결과물을 보장합니다.

## 프로젝트 최종 구조: 런타임 이원화 및 도메인별 실행 전략
1. 도메인별 실행 위치 분리
코딩 도메인 (Hybrid): 로컬-클라우드 링크를 유일하게 활용합니다. 서버(뇌)가 지시하고 사용자의 PC(로컬 에이전트)가 실제 파일을 수정하며 실무를 수행합니다.

저술/문서 도메인 (Cloud-Only): 모든 처리가 서버 내에서 완결됩니다. 복잡한 세계관 데이터와 원문 DB는 서버의 고성능 자원을 활용하여 관리됩니다.

2. 전문가용 vs 대중용 런타임 전략
기획하신 대로 '빌더'가 아닌 런타임의 이원화를 통해 시장을 공략합니다.

[Step 1] 런타임 1: 전문가용 실무 엔진 (1% 대상)
목적: 전문가의 노하우를 '정책'과 '관계'로 데이터화하는 단계입니다.

특징:

사용자에게 더 많은 제어권과 상세한 상태(연료 게이지)를 노출합니다.

전문가는 이 런타임을 통해 **3층 메모리(Structural/Policy)**의 정교한 규칙들을 직접 깎고 검증합니다.

이 과정을 통해 특정 도메인에 최적화된 **'고퀄리티 워크플로우 번들'**이 완성됩니다.

[Step 2] 런타임 2: 대중용 비서 엔진 (99% 대상)
목적: 런타임 1에서 검증된 번들을 이식하여 '딸깍' 한 번에 결과물을 내는 단계입니다.

특징:

복잡한 설정은 숨기고 **'비서'**라는 인터페이스만 제공합니다.

가디언 루프가 백엔드에서 전문가의 기준대로 결과물을 자동 검토하여 품질을 보장합니다.

코딩 도메인 잠금 해제 시, 비서 앱을 통해 내 PC를 원격 제어하여 앱을 만드는 경험을 제공합니다.