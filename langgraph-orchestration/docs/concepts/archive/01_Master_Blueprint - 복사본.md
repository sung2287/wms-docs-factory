# **🚀 \[Master Blueprint\] AI 장기기억 저술 SaaS & 메타 팩토리 아키텍처**

## **1\. 제품의 본질 (Core Identity)**

**"99%의 대중에게 창작의 환상을, 1%의 설계자에게 시스템 통제권을"**

* **대중의 오해:** 딸깍 한 번에 완벽한 장편 소설을 써주는 단일 마법 AI가 존재할 것이다.  
* **우리의 진실:** 완벽한 결과물은 AI의 지능이 아니라, 백엔드에 촘촘하게 설계된 \*\*'결정론적 메타 파이프라인(LangGraph)'\*\*에서 나온다.  
* **가치 제안:** 사용자는 그저 AI와 '대화'만 하지만, 백엔드 시스템이 사용자의 의도를 정해진 스키마에 몰래 채워 넣으며 일관성 있는 거대한 세계관을 자동으로 직조한다.

## **2\. 투트랙 아키텍처 (Builder vs Runtime 분리)**

모든 업무 자동화를 뚝딱 찍어내기 위해, 개발 환경과 서비스 환경을 완벽히 분리한다. (단일 JSON이라는 마케팅 용어 이면의 진짜 엔지니어링 구조)

### **(A) 통제실: 개인용 설계 앱 (Builder / Control Plane)**

* **목적:** 아키텍트가 UI만으로 업무 파이프라인을 깎고 테스트하는 만능 R\&D 랩실.  
* **출력물:** 단순한 JSON 파일 하나가 아니라, 프롬프트(.md), 정책(.yaml), 평가 기준(.json)이 하나로 묶인 \*\*'배포 가능한 파이프라인 번들(Workflow Bundle)과 Manifest'\*\*를 생성.  
* **테스트 (HITL):** 각 노드마다 '수동 개입(Interrupt)' 모드를 켜서 퀄리티를 핀셋 검증.

### **(B) 승격 파이프라인 (Promotion Pipeline)**

* 설계 앱에서 검증을 마친 번들을 제품 엔진으로 밀어 넣는 **'Deploy(승격)'** 과정.  
* **\[LOCK-1\] SSOT 분리 선언:** 승격(Promote)되는 대상은 오직 'Workflow Bundle(컨텍스트 엔지니어링 스펙)'뿐이며, 유저의 실제 데이터(원문/기억/세계관)는 절대 승격 대상에 섞이지 않도록 완벽히 커플링을 차단한다.  
* **\[LOCK-3\] 제한적 핫스왑 (Hot-swap Scope):** 1인 운영의 MVP로 파일 복사/심볼릭 링크 교체를 사용하되, 번들 구성요소별로 허용 범위가 다르다.  
  * *Live Reload 가능:* prompts, rubrics, 일부 routing rule (무중단 패치)  
  * *Restart Required:* step contract, schema 변경, graph shape 변경 (재시작 요구)

### **(C) 실행기: B2C 제품 엔진 (Runtime / Data Plane)**

* **목적:** 대중(99%)이 사용하는 단순하고 직관적인 대화형 UI (엔진은 도메인 입력→실행→결과/상태 반환 역할만 수행).  
* **오토파일럿 (Prod Mode) \[LOCK-2\]:** 런타임 환경에서는 인간의 개입(HITL)이 단순히 '꺼지는' 것이 아니라, **'승인/검수의 주체'를 판사 AI(Judge Policy)로 대체**하는 것이다.  
* **🔥 \[LOCK-4\] 코어 강제 규칙 (Core-enforced Fallback):** Judge Policy의 구체적인 '판단 기준'은 번들에 포함되어 배포되지만, 판단 실패, 보류, 불확실성 발생 시의 처리 구조(재시도/에스컬레이션/중단)는 반드시 Runtime Core에 하드코딩된 Fallback Contract를 따르도록 강제한다. (설계자의 위험한 자동화 정책 배포로 인한 시스템 붕괴 원천 차단)
* **🔥 \[LOCK-5\] 가디언 루프 (Guardian/Validator Loop):** Runtime Core는 실행 전/후에 Policy Memory를 대조하는 Validator Hook을 강제로 실행한다. 이 검사는 **ALLOW(통과), WARN(UI 알림 후 진행), BLOCK(중단)**의 3단계 신호를 반환하며, 시스템 무결성을 실시간으로 수호한다.

## **3\. 백엔드 에이전틱 워크플로우 (Planner-Worker 구조)**

단일 AI의 '기억 상실'과 '설정 붕괴'를 막기 위한 인지 아키텍처.

* **디렉터(판사) 노드:** 가장 똑똑한 AI(고비용). 전체 숲을 보며 설계도를 검토하고 워커에게 "이 부분 충돌 없는지 조사해 와" 지시.  
* **워커(수사관) 노드:** 가성비 AI. 방대한 레포지토리를 뒤져 증거를 수집하고 요약 리포트만 바침.  
* **Letta 장기 기억 (앵커):** 어둠 속(원문 DB)을 비추는 '손전등'. 현재 대화의 맥락을 이해하고 원문 DB의 세계관과 맵핑.

### **3.1 인지 뼈대: 3층 메모리 시스템 (Memory Hierarchy)**

*   **① Semantic Memory (맥락):** 유사한 과거 대화 및 자산 검색 (RAG/Letta Anchor).
*   **② Structural Memory (관계):** 개체 간 위계와 의존성 파악 (Knowledge Graph). "A를 고치면 B가 깨지는가?"를 판단하는 설계의 지도.
*   **③ Policy Memory (규칙):** 절대 변해서는 안 되는 Invariant(불변성). 번들로 주입된 정책(Bundle/Policy)이 여기서 강제됨.

## **4\. 기억과 과금의 헌법 (Memory & BM Constitution)**

**"우리는 기록(데이터)을 인질로 잡지 않는다. 기억의 선명도(컨텍스트)를 팔 뿐이다."**

* **원문 DB (불변의 암흑 창고):** 사용자의 모든 설정, 대화 원문 평생 보존. (S3 콜드 스토리지)  
* **과금 로직 (데이터 티어링):** \* **유료 티어:** 손전등이 최대 출력으로 켜져 비싼 벡터 DB(Hot Storage)로 이관.  
  * **무료 티어 (동면):** 데이터는 S3에 동면(Archive)되나, 최근 대화 맥락만 유지('망각 현상'으로 포장).

### **💡 킬러 UX: "아하 모멘트 (Aha Moment)"**

유료 결제 시 복구 연출:

1. **맥락 연결:** "현재 대화 맥락을 원문 DB의 세계관과 맵핑 중입니다..." (시냅스 연출)  
2. **볼륨 증명:** "인물 14명, 플롯 5개 앵커 연결" (매몰 비용 증명)  
3. **AI의 선빵:** AI가 잊고 있던 과거의 핵심 떡밥을 먼저 짚어주며 대화 시작.

## **5\. 글로벌 확장성 (Global Scalability)**

* **뼈대 독립성:** 랭그래프 엔진 코드 수정 없이 Output Language 변수만 교체.  
* **UI i18n:** 프론트엔드 다국어 매핑(JSON)으로 즉각적인 언어 전환.  
* **크로스 링구얼 기억:** 한국어 원문 DB를 읽고 영미권 톤앤매너로 소설 맵핑.  
* **문화적 튜닝 라우팅:** 설계 앱에서 국가별 감성에 맞춘 전용 '번들'을 제작하여 각국 엔진에 배포.

## **6\. 위기관리 매뉴얼 (4대 윤리 공격 방어망)**

**이 서비스가 공격받는 이유는 비윤리적이어서가 아니라, 인간의 창작·기억·사유를 너무 정확하게 건드리기 때문이다.**

* ① **관계 과금 프레임:** "우리는 관계를 팔지 않는다. 관리 비용을 받는다."  
* ② **창작 착취 프레임:** "우리는 글을 대신 쓰지 않는다. 결정을 내리기 쉽게 만든다." (의사결정 증폭기)  
* ③ **인지 외주화 프레임:** "이 시스템은 사고를 대체하지 않는다. 사고의 흔적을 관리한다."  
* ④ **디스토피아 프레임:** "시스템은 가능성을 제안할 뿐, 결정을 몰래 고정하지 않는다."

## **7\. 핵심 원칙: 연료 게이지 원칙 (The Fuel Gauge Principle)**

**비밀(엔진/설계)은 숨겨도 된다. 하지만 상태(연료 게이지)는 절대 숨겨선 안 된다.**

* 랭그래프 구조나 결정 슬롯은 완벽히 은닉.  
* 단, 시스템의 텔레메트리(Telemetry) 이벤트를 활용해 AI가 \*\*어디까지 기억하고 있는지, 왜 이 결정을 했는지(Explainability)\*\*를 사용자 UI에 투명하게 노출하여 통제감을 부여함.

## **8\. \[Engineering\] 파이프라인 번들 매니페스트 (Manifest Spec)**

Builder에서 Runtime으로 승격(Promote)되는 manifest.json의 핵심 구조. 단순 JSON이 아닌, 버저닝된 아티팩트의 뼈대.

* **A. 정체성 및 호환성:** bundle\_id, bundle\_version, bundle\_hash \+ schema\_version, min\_runtime\_version  
* **B. 구성요소 참조:** prompts\[\] (.md) / policies\[\] (.yaml) / rubrics\[\] (.json)  
* **C. 런타임 적용 범위:** routing (모드 규칙), steps (입출력 Contract)  
* **D. R\&D ↔ Prod 스위치:** \* rd: HITL require\_human: true 허용.  
  * prod: 판사 AI 승인 주체화 (auto\_approver).  
* **E. 관측 및 상태 (Telemetry):** 연료 게이지 UX를 위한 상태 이벤트 정의.  
* **F. 롤백 및 안전장치:** previous\_bundle\_ref 또는 rollback\_to.
* **G. 확장성 포트 (Strategy Injection):** 번들은 단순히 프롬프트만 담는 게 아니라, 해당 도메인에 최적화된 **'리트리벌 전략(Retrieval Strategy)'**과 **'검증 로직(Validator)'**을 런타임에 주입한다. 이를 통해 Core 수정 없이도 도메인별로 각기 다른 3층 메모리 운용 방식이 결정된다.

## **9\. Future Extension (장기 확장 로드맵)**

1인 MVP 운영 이후, 장기적인 SaaS 스케일업을 위해 다음의 권한/배포 모델을 Runtime Core에 추가 확장한다.

* **Stable / Canary 채널 분리 배포:** 새 번들 배포 시 전체 유저가 아닌 일부 트래픽에만 우선 적용하여 퀄리티 검증.  
* **A/B 테스트 라우팅:** 복수의 번들을 동시 운영하여 수익률(CVR)이나 잔존율이 더 높은 프롬프트/정책을 데이터 기반으로 승격.  
* **멀티 테넌트 번들 할당:** 특정 B2B 고객사 전용의 프라이빗 번들(Custom Pipeline) 격리 운영.

## 프로젝트 확장 로드맵: "전문가의 도구에서 모두의 비서로"
[Phase 1] 랭그래프 코어 정교화 및 전문가용 플랫폼 (1% 대상)
이 단계의 목표는 **'통제권'**과 **'노하우 수집'**입니다.

중심 엔진 (LangGraph): 도메인 중립적인 Core Runtime을 완성합니다.

세부 프로젝트 #1 (코딩): 아키텍트와 시니어 개발자를 위한 **'구조적 정합성 엔진'**을 제공합니다.

사용자의 로컬 레포지토리와 연결되어, 복잡한 의존성을 기억하고 검증하는 실무 중심의 기능을 오픈합니다.

세부 프로젝트 #2 (저술): 전문 작가를 위한 **'세계관 정합성 엔진'**을 제공합니다.

3층 메모리(Structural/Policy)를 활용해 수만 장의 설정과 복선을 AI가 관리하도록 돕습니다.

전략적 핵심: 전문가들이 시스템을 사용하며 입력하는 **정책(Policy)**과 의사결정(Decision) 패턴을 데이터화하여 **'워크플로우 번들'**의 퀄리티를 극한으로 끌어올립니다.

[Phase 2] 대중용 '딸깍' 서비스 및 개인 비서 확장 (99% 대상)
1단계에서 검증된 고퀄리티 워크플로우를 대중에게 **'비서'**라는 인터페이스로 공급합니다.

비서 기반 통합 UI: 사용자의 일상 대화를 기억하는 **'Personal AI Secretary'**로 시작합니다.

도메인 팩(Domain Pack) 추가:

"코딩 도메인 추가": 전문가들의 노하우가 응축된 '코딩 번들'을 이식하여, 일반인도 자연어로 "내 PC에서 이런 앱 만들어줘"라고 하면 로컬 에이전트가 실무를 대행합니다.

"저술 도메인 추가": 검증된 '저술 번들'을 통해 누구나 일관성 있는 웹소설이나 보고서를 '딸깍'으로 생성합니다.

전략적 핵심: 대중은 복잡한 설정을 보지 않습니다. 백엔드에서 **가디언 루프(Guardian Loop)**가 전문가의 기준대로 결과물을 자동 검토하여 '딸깍'만으로도 전문가 수준의 결과물을 보장합니다.

🎨 UI/UX 설계안: "심플한 인터페이스 뒤의 강력한 엔진"
1. 기본 레이아웃 (Tri-State Layout)
좌측 사이드바 (Navigation & Context):

세션 관리: 새로운 채팅 시작 버튼 및 과거 세션 목록 슬라이드.

슬라이드 숨기기 버튼: 작업에 집중할 때 사이드바를 완전히 접어 채팅창을 넓게 활용 가능.

전문가용 추가 요소 (런타임 1): 현재 활성화된 도메인 번들(Domain Bundle) 정보 및 정책 상태 요약 표시.

우측 메인 영역 (Chat & Action):

채팅 타임라인: 텍스트, 코드 블록, 이미지 등이 렌더링되는 클린한 채팅창.

상태 스트립 (Top): 현재 접속된 모델명, 연료 게이지(기억 선명도), 그리고 로컬 PC 연결 상태(코딩 도메인 시) 상시 노출.

입력창 (Bottom): 단순한 텍스트 입력창. 복잡한 명령은 프롬프트나 툴바가 아닌 시스템이 의도를 파악하여 처리.

2. 설정의 계층화 (Setting Hierarchy)
"복잡한 것은 숨기고 필요한 것만 노출한다"는 원칙에 따라 설정을 두 단계로 분리합니다.

퀵 토글 (Quick Toggle): 채팅창 상단 또는 입력창 옆에 위치.

도메인 전환 (코딩 ↔ 저술).

모드 수동 전환 (Design ↔ Implement).

통합 설정 메뉴 (Deep Settings): 사이드바 하단 아이콘을 통해 진입.

API/계정 연결: 사용자 고유 API 키 및 로컬 에이전트 연결 설정.

정책 관리 (전문가용): 3층 메모리의 상세 규칙(Policy) 확인 및 수정.

시스템 텔레메트리: AI의 판단 근거와 상세 로그 확인.

3. 사용자 경험(UX) 포인트
의도 중심 인터페이스: 사용자가 설정을 일일이 건드리는 것이 아니라, 대화 중에 "코딩 모드로 바꿔줘"라고 하면 시스템이 내부적으로 currentDomain을 변경하고 UI에 상태만 업데이트합니다.

전문가용 '연료 게이지': AI가 현재 프로젝트의 **구조적 관계(Structural)**나 **정책(Policy)**을 얼마나 정확히 인지하고 있는지 시각적으로 피드백을 주어 신뢰도를 높입니다.

로컬 에이전트 피드백: 코딩 작업 시 로컬 PC에서 파일이 수정되거나 테스트가 돌아가는 과정을 채팅창 내에 가벼운 '액션 카드' 형태로 보고합니다.

세션 계층화 UI/UX 설계안 (Project-Folder Structure)
1. 좌측 사이드바 구조 (The Navigator)
사이드바는 크게 **[프로젝트 폴더]**와 그 내부의 **[세션]**으로 나뉩니다.

최상위 레벨 (Project Folders):

사용자가 생성한 프로젝트 단위(예: AI 저술 프로젝트, CLI 엔진 개발)가 폴더 형태로 존재합니다.

폴더 우측에는 + New Session 버튼이 있어, 해당 프로젝트의 컨텍스트(도메인 번들, 정책 등)를 상속받은 새 세션을 즉시 생성합니다.

하위 레벨 (Session Items):

폴더를 클릭하면 펼쳐지며 내부 세션 목록이 노출됩니다.

각 세션은 챗GPT처럼 세션명 변경, 삭제, 아카이브가 가능합니다.

폴더 미지정 (Default Group):

프로젝트를 지정하지 않은 세션들은 '미분류' 또는 'Default' 폴더에 모입니다.

2. 프로젝트 중심의 세션 생성 흐름
프로젝트 생성 시: 해당 프로젝트에 적용될 **도메인 번들(Coding/Writing)**과 **기본 모델(Gemini/Claude)**을 미리 프리셋으로 설정할 수 있습니다.

세션 생성 시: 사용자는 특정 프로젝트 폴더 안에서 세션을 만듦으로써, 일일이 설정을 건드리지 않고도 해당 프로젝트의 **'기억(Evidence/Decision)'**과 **'정책'**의 유효 범위 안에서 대화를 시작하게 됩니다.