# LangGraph × Letta 결합 아이디어 정리 (앵커 메모리 방식)

## 1) 한 줄 요약

- **LangGraph = 업무 매뉴얼(절차/분기/실행)**
- **Letta = 기억력 좋은 비서(앵커 기억/상기)**

Letta를 “결정/근거를 전부 저장하는 DB”로 쓰는 게 아니라,
새 세션에서도 **“아, 예전에 이거 했던 것 같은데?”**를 떠올리게 해주는 **앵커(Anchor) 기억 레이어**로만 사용한다.

---

## 2) 왜 이런 구조가 필요한가

실전에서 자주 터지는 문제:

- 새 세션이 되면 **기존에 만든 실행 스크립트/실행법**을 잊어버림
- 새 세션이 되면 **어댑터를 어디에 연결했는지** 잊어버림
- 그래서 확인 없이 추측으로 구현/연결해서
  - 똑같은 기능이 두 벌 생기거나
  - 엉뚱한 곳에 꽂아서 충돌/단절이 생김

핵심은 “대화 원문 100% 저장”이 아니라,
**기존에 뭔가 있었음을 상기시키고, 필요할 때 PRD/코드 원문을 확인하게 만드는 것**이다.

---

## 3) 구현 아이디어 구조 (개념)

### 3.1 동작 흐름

1) 사용자가 요청을 한다
   - 예: “새 워크플로우 추가”, “어댑터 연결”, “실행법 알려줘”, “예전에 만들었던 기능 수정”
2) Letta가 먼저 **관련 있을 법한 앵커**를 상기한다
   - “예전에 run:local 실행법 만들었음”
   - “라우터 주입은 run_local.ts에서 했던 것 같음”
   - “PRD-001에서 비슷한 기능 구현했던 기억 있음”
3) LangGraph는 이 신호를 받으면 **원문 확인을 강제**한다
   - PRD 맵/레포 검색
   - 관련 문서/코드/스크립트 열람
4) 확인된 근거를 바탕으로만 다음 단계(설계/수정/실행/지시)를 진행한다

### 3.2 Letta가 저장하는 것 (앵커 메모리)

Letta는 “대화 전체”를 저장하는 게 아니라,
다음처럼 **짧은 네비게이션(어디를 볼지) 정보**만 압축해서 축적한다.

- **RUNBOOK**: 실행법/명령어/옵션
- **ENTRYPOINT**: 시작점(파일/라우트/함수)
- **WIRING**: 어댑터/주입 위치(어디에 꽂는지)
- **CONFIG**: 설정 파일/환경변수/기본값
- **INVARIANT**: 절대 규칙(예: Core는 순수)
- **GOTCHA**: 함정/실패 사례(예: 특정 phase에서 에러)

요약하면, Letta는 “근거 자료”가 아니라 **길 안내 표지판(Anchor)**을 만든다.

### 3.3 Anchor의 속성 (LOCK)

Anchor는 네비게이션 힌트이며 아래 원칙을 따른다:

- **Anchor는 규칙이 아니다**: 실행을 강제하거나 차단하지 않는다.
- **Anchor는 원문을 대체하지 않는다**: 상세 내용은 반드시 Evidence나 Decision 원문을 참조해야 한다.
- **Anchor는 이정표다**: 특정 맥락에서 Evidence 또는 Decision이 존재하는 위치를 가리키는 역할만 수행한다.

### Memory 통합 구조와의 관계

LangGraph의 장기 메모리 타입은 다음 3종으로 제한한다:

- Decision (한 줄 적용 규칙)
- Evidence (근거 스냅샷)
- Anchor (네비게이션 힌트)

Anchor는 Decision이나 Evidence를 대체하지 않는다.
Anchor는 해당 Decision/Evidence가 존재하는 위치를 가리키는 이정표 역할만 수행한다.

---

## 4) 장점

### 4.1 새 세션에서도 ‘상기’가 된다
- “예전에 만들었던 실행법/연결점이 있음”을 먼저 떠올리게 해서 삽질을 크게 줄인다.

### 4.2 추측 기반 중복 구현/오접속이 줄어든다
- Letta가 앵커를 던지고, LangGraph가 원문 확인을 강제하므로
  “확인 없이 새로 만드는” 흐름이 구조적으로 차단된다.

### 4.3 10년 스케일에서도 부담이 적다
- 대화 원문을 전량 저장하지 않고, **핵심만 압축 저장**하므로
  데이터가 커져도 검색 효율이 무너지기 어렵다.

### 4.4 워크플로우가 늘어도 Letta는 크게 바뀌지 않는다
- Letta는 도메인별 절차를 기억하는 게 아니라,
  어디를 봐야 하는지(앵커 타입)를 기억하므로 재사용성이 높다.

---

## 5) 주의점 (이 구조의 룰)

- Letta는 **절차 판단/분기/실행**을 맡지 않는다 (그건 LangGraph)
- Letta는 “정확한 근거”를 보장하지 않아도 된다
  - 대신, LangGraph가 **PRD/코드 원문 확인을 강제**한다
- 목표는 ‘완벽한 기억’이 아니라
  **“있었음/어디를 볼지”를 상기시키는 것**이다

---

## 6) 어디에 들어가나 (개념적 위치)

- 세션 저장(단기 상태) 영역이 아니라
- **메모리/리트리벌(장기 앵커) 영역**에 속한다

즉, “세션 복구”가 아니라 “새 세션에서도 길을 잃지 않게 하는 상기 시스템”이다.

