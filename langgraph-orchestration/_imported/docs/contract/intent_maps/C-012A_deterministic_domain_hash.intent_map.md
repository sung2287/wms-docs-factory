# C-012A: Deterministic & Domain-Aware Hash Intent Map

## 1. Intent 정의 (Intent Definitions)

이 문서는 PRD-012A(Deterministic Plan Hash & Domain-Aware Hash)의 의미적 의도(Intent)를 고정하며, 기술 구현(B/D) 이전에 "왜 이 변경이 필요한가"와 "어떤 의미 경계를 보호하려는가"를 정의한다.

### 1.1 Intent: Preserve Session Integrity
- **발생 배경**: 세션 복구 시점에 이전 실행 환경과 현재 실행 환경의 동일성을 검증하는 유일한 수단이 Hash이다.
- **보호하려는 의미 경계**: "과거의 실행 컨텍스트"와 "현재의 실행 컨텍스트" 사이의 완전한 일치성.
- **위반 시 발생하는 시스템 리스크**: 잘못된 세션 복구로 인한 상태 오염, 런타임 크래시, 의도치 않은 모델/도메인에서의 실행 지속.
- **PRD-012과의 연결성**: Override UX 도입 시, 오버라이드된 환경이 기존 세션과 충돌하지 않도록 보장하는 안전장치.

### 1.2 Intent: Enforce Deterministic Hash
- **발생 배경**: `JSON.stringify`의 기본 동작은 객체 키 순서를 보장하지 않아, 동일 데이터임에도 실행 환경에 따라 다른 해시를 생성할 위험이 있다.
- **보호하려는 의미 경계**: 데이터의 "내용적 동일성"이 "형태적 표현(직렬화 순서)"에 의존하지 않아야 함.
- **위반 시 발생하는 시스템 리스크**: 데이터는 변경되지 않았음에도 해시 불일치로 인해 세션 복구가 거부되는 가짜 양성(False Positive) 오류 발생.
- **PRD-012과의 연결성**: 신뢰할 수 없는 해시는 오버라이드 검증의 근간을 흔든다.

### 1.3 Intent: Enforce Domain-Aware Boundary
- **발생 배경**: 기존 해시는 도메인 정보를 포함하지 않아, 서로 다른 도메인에서 동일한 플랜을 실행할 경우 세션이 혼용될 위험이 있다.
- **보호하려는 의미 경계**: "도메인"은 실행의 논리적 격리 벽(Isolator)이며, 해시는 이를 인지해야 함.
- **위반 시 발생하는 시스템 리스크**: 도메인 A의 세션이 도메인 B에서 복구되어 보안 정책 위반 및 데이터 유출 발생.
- **PRD-012과의 연결성**: 도메인별 오버라이드 정책이 상이할 수 있으므로 도메인 인지는 필수적임.

### 1.4 Intent: Prevent Secret Contamination
- **발생 배경**: API Key 등의 민감 정보가 해시 계산에 포함될 경우, 키 변경만으로도 세션이 무효화되거나 로그/디버그 정보에 비밀번호가 노출될 위험이 있다.
- **보호하려는 의미 경계**: "실행 설정(Meta)"과 "인증 수단(Secret)"의 엄격한 분리.
- **위반 시 발생하는 시스템 리스크**: 보안 자격 증명 유출, 키 로테이션 시 모든 세션 파괴.
- **PRD-012과의 연결성**: 오버라이드는 모델/공급자에 집중하며, 인증 정보는 인프라스트럭처 레벨에서 관리됨을 명시.

### 1.5 Intent: Protect Structural Immutability
- **발생 배경**: 기능을 위해 Core 인터페이스(`ExecutionPlan` 등)를 수정하려는 유혹이 있으나, 이는 하위 호환성을 파괴한다.
- **보호하려는 의미 경계**: Core 데이터 구조의 안정성 및 하위 호환성 유지.
- **위반 시 발생하는 시스템 리스크**: 기존 저장된 모든 세션 데이터의 읽기 실패, 시스템 아키텍처의 파편화.
- **PRD-012과의 연결성**: Core 수정 없이 Orchestrator 레벨에서 해결하는 "Core-Zero-Mod" 원칙 고수.

---

## 2. Meaning Boundary 명시 (Meaning Boundaries)

### 2.1 왜 provider/model은 hash에 포함되어야 하는가?
동일한 `ExecutionPlan`이라도 공급자(Provider)나 모델(Model)이 달라지면 추론 결과와 토큰 처리 방식이 완전히 달라진다. 따라서 이는 실행의 "동일성"을 결정짓는 핵심 메타데이터이므로 해시에 반드시 포함되어야 한다.

### 2.2 왜 currentDomain은 hash에 포함되어야 하는가?
도메인은 권한과 정책의 경계이다. 동일한 동작이라도 "관리 도메인"과 "사용자 도메인"에서의 의미는 다르다. 도메인 오염은 시스템의 논리적 붕괴를 초래하므로 해시를 통해 물리적으로 격리해야 한다.

### 2.3 왜 secret(apiKey 등)은 제외되어야 하는가?
Secret은 실행의 "정체성"이 아니라 실행을 위한 "통행증"이다. 통행증이 바뀐다고 해서 실행의 내용이 바뀌는 것은 아니다. 또한 보안상 해시 입력값 추적 과정에서 Secret이 노출되는 것을 원칙적으로 차단해야 한다.

### 2.4 왜 JSON stringify의 비결정성은 세션 보호를 위협하는가?
비결정성은 "우연한 실패"를 만든다. 시스템은 예측 가능해야 하며, 데이터가 변하지 않았는데도 시스템이 거부하는 현상은 사용자의 신뢰를 저해하고 디버깅을 불가능하게 만든다.

---

## 3. Non-Intent (의도 아님)

- **성능 개선 목적 아님**: 해시 계산 속도 향상을 위한 최적화는 본 문서의 관심사가 아니다.
- **기능 확장 목적 아님**: 새로운 실행 기능을 추가하기 위한 변경이 아니다.
- **Policy 수정 목적 아님**: 기존 정책 파일의 내용을 변경하거나 해석 방식을 바꾸는 것이 아니다.
- **Core 구조 변경 목적 아님**: `src/core` 내부의 인터페이스나 핵심 로직을 리팩토링하는 것이 아니다.

---

## 4. Hierarchy 정합성 확인 (Architectural Alignment)

- **Core-Zero-Mod 원칙**: `src/core`를 수정하지 않고 외부 메타데이터 구성을 통해 해시를 강화함으로써 이 원칙을 완벽히 준수한다.
- **Session-Hash-Strict 원칙**: 해시 입력 필드를 명시적으로 고정하고 결정론적 방식을 강제하여 "엄격한 검증" 철학을 실현한다.
- **Domain vs Phase Separation 원칙**: 도메인을 해시에 포함함으로써 실행 페이즈와 도메인 간의 의미적 경계를 명확히 분리한다.
- **Decision/Evidence SSOT 분리 원칙**: 해시는 "결정(Plan)"과 그 "맥락(Metadata)"의 요약본이며, 실행 증거(Evidence)와는 독립적으로 관리된다.

---

## 5. LOCK 선언

- **Deterministic Hash는 선택 사항이 아니다.** (반드시 Stable Serialization 사용)
- **Domain은 의미 경계이며, Hash에 포함되어야 한다.** (누락 시 위반)
- **Secret은 절대 Hash에 포함되지 않는다.** (보안 제약)
- **Hash 입력 필드는 명시적으로 고정된다.** (provider, model, mode, domain)
