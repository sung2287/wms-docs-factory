# PRD-001: Core Runtime Skeleton (Policy-Neutral Engine)

## Objective
Establish a minimal, domain-neutral orchestration engine skeleton that executes a fixed pipeline while remaining completely agnostic to specific workflows or domains.

## Background
To prevent "domain bleed" and hardcoded logic, the runtime must be a pure "context-assembling machine." It should not know about specific tasks (like coding or PRD writing) but should know how to execute the assembly process.

## Scope
- Implementation of the core `LangGraph` state and nodes.
- Definition of the fixed execution pipeline.
- Abstraction of memory and document loading interfaces.

### Dependency on PRD-002
- Policy directory structure is defined in PRD-002.
- CLI `--profile` behavior (default = default) is defined in PRD-002.
- `PolicyInterpreter` is fully responsible for generating `executionPlan`.
- PRD-001 assumes `executionPlan` is already resolved before Core execution.

### Explicit Exclusions (Locked)
PRD-001 does NOT:
- Define policy file paths.
- Implement profile resolution.
- Implement trigger logic.
- Perform `session_state.json` persistence.
- Interpret policy YAML files.

It ONLY:
- Executes `executionPlan`.
- Maintains execution state.
- Invokes abstract step handlers.

## Non-Goals
- Implementation of specific phases (e.g., IMPLEMENT, DIAGNOSE).
- Built-in repository scanning logic.
- Domain-specific prompt templates.

## Architecture
The runtime executes a fixed, linear pipeline where each node's behavior is parameterized by the current `policyRef`:

```text
[CLI]
  --> PolicyInterpreter (PRD-002)  // resolves executionPlan + policyRef + currentMode(metadata)
  --> Core Engine (PRD-001)
        --> LoadDocsForMode (Bundle-based)
        --> ContextSelect (Memory + Retrieval)
        --> PromptAssemble (Template-based)
        --> LLMCall (Adapter-based)
        --> MemoryWrite (Persistence)
[END]
```

The core engine executes an abstract execution plan generated by the PolicyInterpreter. The engine does not interpret workflow semantics; it only executes ordered steps defined by the resolved plan. The `executionPlan` is the only structure interpreted by the core engine. Mode identifiers are treated as metadata and have no behavioral meaning inside the engine.

## Data Structures
### GraphState
- **`executionPlan`**: Step[] (An ordered list of abstract execution steps resolved by the policy layer.)
- **`currentMode`**: string (Optional metadata label provided by policy; not interpreted by the core engine.)
- `memoryRef`: object (Pointer/ID for the conversation history).
- `docBundleRef`: string[] (List of document IDs/paths to be loaded).
- `policyRef`: object (The active policy configuration, immutable for the duration of a single execution cycle).
- `assembledPrompt`: string (The final string sent to the LLM).
- `lastResponse`: string (The raw output from the LLM).

## Execution Rules
1. **No Hardcoding:** The engine must not contain any strings related to "coding," "tests," or specific project phases.
2. **Policy Dependency:** Every node must rely on the provided `executionPlan` and `policyRef`.
3. **Workflow Neutrality:** The core engine does not determine workflow transitions. It executes the plan resolved by the `PolicyInterpreter`.
4. **No Mode-Based Branching:** The core engine must not branch logic based on `currentMode` values. All execution behavior must derive solely from the `executionPlan` structure.
5. **Fail-Fast Guarantee:**  
If policy resolution fails, the runtime MUST terminate before invoking the Core Engine.  
Any fallback behavior, if supported, MUST be defined and handled exclusively by the `PolicyInterpreter` (PRD-002), not by the Core Engine.

## Success Criteria
- The engine can execute a full loop and return an LLM response.
- The engine can run in a "blank" state without any domain-specific files.
- Switching a `policyRef` object at runtime changes the context assembly behavior without modifying code.
